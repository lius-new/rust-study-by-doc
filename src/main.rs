fn main() {
    // 对指向堆中的变量赋值给另一变量的时候会发生移动,而如果不想这类情况可以使用引用

    // 引用实际上是一个地址可以访问存储该地址的属于其他变量的数据. 与指针的差别在于指向的地址永远存在值
    // & 符号表示引用,可以操作指针中的值但不获取所有权. 因此是&获取的值不会在作用域结束的时候会销毁堆中的数据

    // 事实上 let s1 = &s; 这样将一个&引用值赋值给s1 叫做借用,即s1借用s.
    // 并非所有权而是引用

    let s = String::from("hello");
    let s1 = &s;
    // s1.push_str("hello"); // 不允许修改引用的值,因为默认是不可变引用

    let mut s = s; // 此时发生了移动,所有权发生变化
    let s1 = &mut s;
    // let s2 = &mut s; // 不可同时借用两个可变引用, 可变引用同时只能发生一次借用, 必须在前一次借用结束后 .实际上禁用下面的代码,那么就没有同时存在,因为前者可变引用如果没有使用在执行赋值后借用就已经结束
    s1.push_str(" world");  // 可变引用是可以修改引用的值的

    // 不可以同时拥有两个可变引用为了避免数据竞争. 如果允许就会有:
    // 两个或多个指针同时访问同一数据
    // 至少有一个指针被用来写入数据
    // 没有同步访问机制
    // **因此: rust中不能有多个变量同时拥有可变引用.这是为了避免不可控的错误 **

    // 不能在同时拥有可变引用的情况下拥有不可变引用
    // 不可变引用常常不希望别人修改数据,而可变引用创建出来就是为了修改数据,两者行为是冲突的
    let mut s1 = String::from("hello");
    let r1 = &s1; // 多个不可变引用发生的借用关系是允许的,它们并不影响
    let r2 = &s1; // 多个不可变引用发生的借用关系是允许的,它们并不影响
    // let r3 = &mut s1;
    // println!("{}{}{}", r1, r2, r3) // 此时这样的情况表示是同时存在的,这并不允许

    println!("{}{}", r1, r2 );
    let r3 = &mut s1;
    println!("{}", r3);

}

// 函数使用引用来作为参数,函数结束后并不会销毁数据
fn calculate_length(s: &String) -> usize {
    s.len()
}